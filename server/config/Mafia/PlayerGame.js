// Generated by CoffeeScript 1.6.3
(function() {
  var Heap, PlayerGame, PlayerGameParent, log,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Heap = require('heap');

  log = function() {
    var thelog, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      thelog = arguments[_i];
      _results.push(console.log(thelog));
    }
    return _results;
  };

  PlayerGameParent = (function() {
    function PlayerGameParent(roleObject, playerInfo, gameEngine, config) {
      var action, _i, _len, _ref;
      this.roleObject = roleObject;
      this.config = config;
      this.playerInfo = playerInfo;
      this.gameEngine = gameEngine;
      this.events = {};
      this._buffer = [];
      this.currentState = {};
      roleObject.initializeState(this.currentState);
      this.currentState.name = playerInfo.name;
      this.active = roleObject.active;
      this.validateActive = roleObject.validateActive;
      this.gameEngine.addWinCondition(this.roleObject.winCondition);
      _ref = roleObject.actions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        action = _ref[_i];
        this.addToBuffer(action, roleObject[action]);
      }
      this._flushBuffer();
    }

    PlayerGameParent.prototype.getCurrentState = function() {
      return this.currentState;
    };

    PlayerGameParent.prototype.on = function(action, args) {
      var action_object, activeBound, persistent, validateBound;
      if (action === 'active') {
        if (this.validateActive(args, this.currentState, this.gameEngine)) {
          activeBound = this.active.func.bind(void 0, args, this.currentState, this.gameEngine);
          validateBound = this.validateActive.bind(void 0, args, this.currentState, this.gameEngine);
          this.gameEngine.getCommandManager().addActive(this.active.priority, activeBound, this.currentState, validateBound);
          return [true, this.active.immediate];
        }
        return [false, this.active.immediate];
      } else {
        while (this.events[action].size() > 0) {
          action_object = this.events[action].pop();
          persistent = action_object.func(args, this.currentState, this.gameEngine);
          if (persistent) {
            this.addToBuffer(action, action_object);
          }
        }
        return this._flushBuffer();
      }
    };

    PlayerGameParent.prototype.addToBuffer = function(action, action_object) {
      return this._buffer.push([action, action_object]);
    };

    PlayerGameParent.prototype._flushBuffer = function() {
      var action, buffered, reaction, _results;
      _results = [];
      while (this._buffer.length > 0) {
        buffered = this._buffer.pop();
        action = buffered[0];
        reaction = buffered[1];
        if (!this.events[action]) {
          this.events[action] = new Heap(function(a, b) {
            if (a.priority < b.priority) {
              return 1;
            } else {
              return -1;
            }
          });
        }
        _results.push(this.events[action].push(reaction));
      }
      return _results;
    };

    PlayerGameParent.prototype._add = function(action, actionsobject) {
      if (!this.events[action]) {
        this.events[action] = new Heap(function(a, b) {
          if (a.priority < b.priority) {
            return 1;
          } else {
            return -1;
          }
        });
      }
      return this.events[action].push(actionsobject);
    };

    PlayerGameParent.prototype.endTurn = function(turn) {
      return this._flushBuffer();
    };

    return PlayerGameParent;

  })();

  PlayerGame = (function(_super) {
    __extends(PlayerGame, _super);

    function PlayerGame(roleObject, playerInfo, gameEngine, config) {
      PlayerGame.__super__.constructor.call(this, roleObject, playerInfo, gameEngine, config);
    }

    PlayerGame.prototype.changeRole = function(roleObject) {
      var action, action_heap, action_object, _i, _len, _ref, _ref1;
      _ref = this.actions;
      for (action in _ref) {
        if (!__hasProp.call(_ref, action)) continue;
        action_heap = _ref[action];
        while (action_heap.size() > 0) {
          action_object = action_heap.pop();
          if (action_object.roleID === !this.roleID) {
            this.addToBuffer(action, action_object);
          }
        }
        delete this.actions[action];
      }
      _ref1 = roleObject.actions;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        action = _ref1[_i];
        this.addToBuffer(action, roleObject[action]);
      }
      this._flushBuffer();
      this.initializeState = roleObject.initializeState;
      return this.initializeState(this.currentState);
    };

    PlayerGame.prototype.addToVisited = function(target) {
      var currentTurn;
      currentTurn = this.gameEngine.getTurn();
      if (!this.currentState.visited[currentTurn]) {
        this.currentState.visited[currentTurn] = [];
      }
      return this.currentState.visited[currentTurn].push(target);
    };

    PlayerGame.prototype.addToVisitors = function(visitor) {
      var currentTurn;
      currentTurn = this.gameEngine.getTurn();
      if (!this.currentState.visitors[currentTurn]) {
        this.currentState.visitors[currentTurn] = [];
      }
      return this.currentState.visitors[currentTurn].push(visitor);
    };

    return PlayerGame;

  })(PlayerGameParent);

  exports.PlayerGame = PlayerGame;

}).call(this);

/*
//@ sourceMappingURL=PlayerGame.map
*/
